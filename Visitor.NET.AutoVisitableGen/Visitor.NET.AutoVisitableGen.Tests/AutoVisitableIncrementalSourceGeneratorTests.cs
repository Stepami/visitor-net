using System.Diagnostics;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace Visitor.NET.AutoVisitableGen.Tests;

public class AutoVisitableIncrementalSourceGeneratorTests
{
    [Theory]
    [InlineData("class")]
    [InlineData("record")]
    public void Initialize_DerivedTypeVisitable_ImplementationCorrectlyGenerated(string keyword)
    {
        var inputCompilation = CreateCompilation($@"
using Visitor.NET;

namespace MyNamespace;

public abstract {keyword} BinaryTreeNode : IVisitable<BinaryTreeNode>
{{
    public abstract TReturn Accept<TReturn>(
        IVisitor<BinaryTreeNode, TReturn> visitor);
}}

[AutoVisitable<BinaryTreeNode>]
public partial {keyword} Operation(
    char Symbol,
    BinaryTreeNode Left,
    BinaryTreeNode Right) : BinaryTreeNode
{{
}}
");

        var expectedSource = $@"// <auto-generated/>

using Visitor.NET;

namespace MyNamespace;

public partial {keyword} Operation :
    IVisitable<Operation>
{{
    public override TReturn Accept<TReturn>(
        IVisitor<BinaryTreeNode, TReturn> visitor) =>
        Accept(visitor);

    public TReturn Accept<TReturn>(
        IVisitor<Operation, TReturn> visitor) =>
        visitor.Visit(this);
}}
";

        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees
            .Single(t => t.FilePath.EndsWith("Operation.g.cs"));

        Assert.Equal(
            expectedSource,
            generatedFileSyntax.GetText().ToString(),
            ignoreLineEndingDifferences: true);
    }

    [Fact]
    public void Initialize_DerivedTypeVisitable_GeneratedWithoutFullTypeName()
    {
        const string input = @"using Visitor.NET;

namespace MyNamespace.Nodes
{
    public abstract record BinaryTreeNode : IVisitable<BinaryTreeNode>
    {
        public abstract TReturn Accept<TReturn>(
            IVisitor<BinaryTreeNode, TReturn> visitor);
    }
}

namespace MyNamespace
{
    using Nodes;
    [AutoVisitable<BinaryTreeNode>]
    public partial record Parenthesis(BinaryTreeNode Node) : BinaryTreeNode;
}";
        const string expectedSource = @"// <auto-generated/>

using Visitor.NET;

namespace MyNamespace;

public partial record Parenthesis :
    IVisitable<Parenthesis>
{
    public override TReturn Accept<TReturn>(
        IVisitor<MyNamespace.Nodes.BinaryTreeNode, TReturn> visitor) =>
        Accept(visitor);

    public TReturn Accept<TReturn>(
        IVisitor<Parenthesis, TReturn> visitor) =>
        visitor.Visit(this);
}
";
        var inputCompilation = CreateCompilation(input);
        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees
            .Single(t => t.FilePath.EndsWith("Parenthesis.g.cs"));

        Assert.Equal(
            expectedSource,
            generatedFileSyntax.GetText().ToString(),
            ignoreLineEndingDifferences: true);
    }

    [Fact]
    public void Initialize_DerivedTypeVisitable_GeneratedWithFullTypeName()
    {
        const string input = @"using Visitor.NET;

namespace MyNamespace
{
    public abstract record BinaryTreeNode : IVisitable<BinaryTreeNode>
    {
        public abstract TReturn Accept<TReturn>(
            IVisitor<BinaryTreeNode, TReturn> visitor);
    }
}

namespace MyNamespace.Test
{
    using Nodes;
    [AutoVisitable<BinaryTreeNode>]
    public partial record Parenthesis(BinaryTreeNode Node) : BinaryTreeNode;
}";
        const string expectedSource = @"// <auto-generated/>

using Visitor.NET;

namespace MyNamespace.Test;

public partial record Parenthesis :
    IVisitable<Parenthesis>
{
    public override TReturn Accept<TReturn>(
        IVisitor<MyNamespace.BinaryTreeNode, TReturn> visitor) =>
        Accept(visitor);

    public TReturn Accept<TReturn>(
        IVisitor<Parenthesis, TReturn> visitor) =>
        visitor.Visit(this);
}
";
        var inputCompilation = CreateCompilation(input);
        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation,
            out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees
            .Single(t => t.FilePath.EndsWith("Parenthesis.g.cs"));

        Assert.Equal(
            expectedSource,
            generatedFileSyntax.GetText().ToString(),
            ignoreLineEndingDifferences: true);
    }

    [Theory]
    [InlineData("")]
    [InlineData("namespace MyNamespace;")]
    [InlineData("namespace Root.MyNamespace;")]
    public void Initialize_DerivedTypeVisitable_GeneratedWithCorrectNamespaces(string @namespace)
    {
        var input = $@"using Visitor.NET;

{@namespace}

public abstract class BinaryTreeNode : IVisitable<BinaryTreeNode>
{{
    public abstract TReturn Accept<TReturn>(
        IVisitor<BinaryTreeNode, TReturn> visitor);
}}

[AutoVisitable<BinaryTreeNode>]
public partial class Operation(
    char Symbol,
    BinaryTreeNode Left,
    BinaryTreeNode Right) : BinaryTreeNode
{{
}}";


        var expectedSource = $@"// <auto-generated/>

using Visitor.NET;

{@namespace}

public partial class Operation :
    IVisitable<Operation>
{{
    public override TReturn Accept<TReturn>(
        IVisitor<BinaryTreeNode, TReturn> visitor) =>
        Accept(visitor);

    public TReturn Accept<TReturn>(
        IVisitor<Operation, TReturn> visitor) =>
        visitor.Visit(this);
}}
";

        var compilation = CreateCompilation(input);

        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees.Single(t => t.FilePath.EndsWith("Operation.g.cs"));

        Assert.Equal(expectedSource, generatedFileSyntax.GetText().ToString(), ignoreLineEndingDifferences: true);
    }

    [Theory]
    [InlineData("public", "public")]
    [InlineData("internal", "internal")]
    [InlineData("", "internal")]
    public void Initialize_DerivedTypeVisitable_GeneratedWithCorrectAccessModifiers(string accessModifier,
        string expectedAccessModifier)
    {
        var input = $@"using Visitor.NET;

namespace MyNamespace;

{accessModifier} abstract class BinaryTreeNode : IVisitable<BinaryTreeNode>
{{
    public abstract TReturn Accept<TReturn>(
        IVisitor<BinaryTreeNode, TReturn> visitor);
}}

[AutoVisitable<BinaryTreeNode>]
{accessModifier} partial class Operation(
    char Symbol,
    BinaryTreeNode Left,
    BinaryTreeNode Right) : BinaryTreeNode
{{
}}";

        var expectedSource = $@"// <auto-generated/>

using Visitor.NET;

namespace MyNamespace;

{expectedAccessModifier} partial class Operation :
    IVisitable<Operation>
{{
    public override TReturn Accept<TReturn>(
        IVisitor<BinaryTreeNode, TReturn> visitor) =>
        Accept(visitor);

    public TReturn Accept<TReturn>(
        IVisitor<Operation, TReturn> visitor) =>
        visitor.Visit(this);
}}
";

        var compilation = CreateCompilation(input);

        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees.Single(t => t.FilePath.EndsWith("Operation.g.cs"));

        Assert.Equal(expectedSource, generatedFileSyntax.GetText().ToString(), ignoreLineEndingDifferences: true);
    }

    [Theory]
    [InlineData("class")]
    [InlineData("record")]
    public void Initialize_NestedDerivedTypeVisitable_NestedImplementationCorrectlyGenerated(string keyword)
    {
        var inputCompilation = CreateCompilation($@"
using Visitor.NET;

namespace MyNamespace;

public abstract partial {keyword} BinaryTreeNode : IVisitable<BinaryTreeNode>
{{

    [AutoVisitable<BinaryTreeNode>]
    public partial {keyword} Operation(
        char Symbol,
        BinaryTreeNode Left,
        BinaryTreeNode Right) : BinaryTreeNode
    {{
    }}

    public abstract TReturn Accept<TReturn>(
        IVisitor<BinaryTreeNode, TReturn> visitor);
}}
");

        var expectedSource = $@"// <auto-generated/>

using Visitor.NET;

namespace MyNamespace;

public partial {keyword} BinaryTreeNode
{{
    public partial {keyword} Operation :
        IVisitable<Operation>
    {{
        public override TReturn Accept<TReturn>(
            IVisitor<BinaryTreeNode, TReturn> visitor) =>
            Accept(visitor);

        public TReturn Accept<TReturn>(
            IVisitor<Operation, TReturn> visitor) =>
            visitor.Visit(this);
    }}
}}
";

        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        
        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees
            .Single(t => t.FilePath.EndsWith("Operation.g.cs"));

        Assert.Equal(
            expectedSource,
            generatedFileSyntax.GetText().ToString(),
            ignoreLineEndingDifferences: true);
    }
    
    [Theory]
    [InlineData(@"
using Visitor.NET;

namespace MyNamespace;

public partial class MyClassLevelTwo
{
    public abstract partial record BinaryTreeNode : IVisitable<BinaryTreeNode>
    {
        [AutoVisitable<BinaryTreeNode>]
        public partial record Number(double Value) : BinaryTreeNode;

        public abstract TReturn Accept<TReturn>(IVisitor<BinaryTreeNode, TReturn> visitor);
    }
}
", $@"// <auto-generated/>

using Visitor.NET;

namespace MyNamespace;

public partial class MyClassLevelTwo
{{
    public partial record BinaryTreeNode
    {{
        public partial record Number :
            IVisitable<Number>
        {{
            public override TReturn Accept<TReturn>(
                IVisitor<BinaryTreeNode, TReturn> visitor) =>
                Accept(visitor);

            public TReturn Accept<TReturn>(
                IVisitor<Number, TReturn> visitor) =>
                visitor.Visit(this);
        }}
    }}
}}
")]
    [InlineData(@"
using Visitor.NET;

namespace MyNamespace;

public partial class MyClassLevelTree
{
    public partial class MyClassLevelTwo
    {
        public abstract partial record BinaryTreeNode : IVisitable<BinaryTreeNode>
        {
            [AutoVisitable<BinaryTreeNode>]
            public partial record Number(double Value) : BinaryTreeNode;

            public abstract TReturn Accept<TReturn>(IVisitor<BinaryTreeNode, TReturn> visitor);
        }
    }
}
", $@"// <auto-generated/>

using Visitor.NET;

namespace MyNamespace;

public partial class MyClassLevelTree
{{
    public partial class MyClassLevelTwo
    {{
        public partial record BinaryTreeNode
        {{
            public partial record Number :
                IVisitable<Number>
            {{
                public override TReturn Accept<TReturn>(
                    IVisitor<BinaryTreeNode, TReturn> visitor) =>
                    Accept(visitor);

                public TReturn Accept<TReturn>(
                    IVisitor<Number, TReturn> visitor) =>
                    visitor.Visit(this);
            }}
        }}
    }}
}}
")]
    public void Initialize_MultipleNestedDerivedTypeVisitable_NestedImplementationCorrectlyGenerated(string inputCode, string expectedOutput)
    {
        var inputCompilation = CreateCompilation(inputCode);

        var expectedSource = expectedOutput;

        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
        
        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees
            .Single(t => t.FilePath.EndsWith("Number.g.cs"));

        Assert.Equal(
            expectedSource,
            generatedFileSyntax.GetText().ToString(),
            ignoreLineEndingDifferences: true);
    }
    

    private static Compilation CreateCompilation(string source) =>
        CSharpCompilation.Create("compilation",
            new[] { CSharpSyntaxTree.ParseText(source) },
            new[] { MetadataReference.CreateFromFile(typeof(Binder).GetTypeInfo().Assembly.Location) },
            new CSharpCompilationOptions(OutputKind.ConsoleApplication));
}