using System.Diagnostics;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace Visitor.NET.AutoVisitableGen.Tests;

public partial class AutoVisitableIncrementalSourceGeneratorTests
{
    [Fact]
    public void Initialize_BaseTypeInterface_ImplementationCorrectlyGenerated()
    {
        var inputCompilation = CreateCompilation(@"
using Visitor.NET;

namespace MyNamespace;

public interface IBinaryTreeNode : IVisitable<IBinaryTreeNode>
{
}

[AutoVisitable<IBinaryTreeNode>]
public partial record Operation(char Symbol) : IBinaryTreeNode
{
}
");

        const string expectedSource = @"// <auto-generated/>

using System.Diagnostics.CodeAnalysis;
using Visitor.NET;

namespace MyNamespace;

public partial record Operation :
    IVisitable<Operation>
{
    [ExcludeFromCodeCoverage]
    public TReturn Accept<TReturn>(
        IVisitor<IBinaryTreeNode, TReturn> visitor)
    {
        IVisitor<Operation, TReturn> concreteVisitor = visitor;
        return Accept(concreteVisitor);
    }

    [ExcludeFromCodeCoverage]
    public TReturn Accept<TReturn>(
        IVisitor<Operation, TReturn> visitor) =>
        visitor.Visit(this);
}
";

        var generator = new AutoVisitableIncrementalSourceGenerator();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);

        driver = driver.RunGeneratorsAndUpdateCompilation(inputCompilation, out var outputCompilation, out var diagnostics);
        Debug.Assert(diagnostics.IsEmpty);
        Debug.Assert(outputCompilation.SyntaxTrees.Count() == 3);

        var runResult = driver.GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees
            .Single(t => t.FilePath.EndsWith("Operation.g.cs"));

        Assert.Equal(
            expectedSource,
            generatedFileSyntax.GetText().ToString(),
            ignoreLineEndingDifferences: true);
    }
}