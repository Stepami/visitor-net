using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Visitor.NET.AutoVisitableGen;

[Generator]
public class AutoVisitableIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string AttributeSourceCode = @"// <auto-generated/>

namespace Visitor.NET;
                   
[System.AttributeUsage(System.AttributeTargets.Class)]
public class AutoVisitableAttribute<T> : System.Attribute
    where T : IVisitable<T>
{
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "AutoVisitableAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (s, _) => s is TypeDeclarationSyntax { AttributeLists.Count: > 0 } candidate
                              and not InterfaceDeclarationSyntax &&
                          candidate.Modifiers.Any(SyntaxKind.PublicKeyword) &&
                          candidate.Modifiers.Any(SyntaxKind.PartialKeyword) &&
                          !candidate.Modifiers.Any(SyntaxKind.StaticKeyword),
                static (ctx, _) => GetTypeDeclarationForSourceGen(ctx))
            .Where(static t => t is not null)
            .Select(static (x, _) => x!);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            static (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static VisitableInfo? GetTypeDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

        var attribute = typeDeclarationSyntax.AttributeLists
            .SelectMany(attributeListSyntax => attributeListSyntax.Attributes)
            .FirstOrDefault(attributeSyntax =>
            {
                if (ModelExtensions.GetSymbolInfo(
                        context.SemanticModel,
                        attributeSyntax).Symbol is not IMethodSymbol)
                    return false;

                if (attributeSyntax.Name is not GenericNameSyntax genericAttribute)
                    return false;

                var attributeName = genericAttribute.Identifier.Text;

                return attributeName is "AutoVisitable" or "AutoVisitableAttribute";
            });

        var baseType = (attribute?.Name as GenericNameSyntax)?
            .TypeArgumentList.Arguments
            .FirstOrDefault()?.ToString();
        if (baseType is null)
            return null;

        TypeKind? kind = typeDeclarationSyntax.Keyword.Text switch
        {
            "class" => TypeKind.Class,
            "record" => TypeKind.Record,
            _ => null
        };
        if (kind is null)
            return null;

        var visitableName = typeDeclarationSyntax.Identifier.Text;
        
        
        // check all types in hierarchy are partial
        SyntaxNode currentType = typeDeclarationSyntax;
        while (currentType is not BaseNamespaceDeclarationSyntax)
        {
            if (currentType is BaseTypeDeclarationSyntax b && !b.Modifiers.Any(SyntaxKind.PartialKeyword))
                return null;

            currentType = currentType.Parent;
        }

        return new VisitableInfo(
            kind.Value,
            baseType,
            visitableName,
            typeDeclarationSyntax);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<VisitableInfo> visitableInfos) 
    {
        foreach (var (typeKind, baseTypeName, visitableTypeName, typeDeclarationSyntax) in visitableInfos)
        {
            var semanticModel = compilation.GetSemanticModel(typeDeclarationSyntax.SyntaxTree);

            if (ModelExtensions.GetDeclaredSymbol(
                    semanticModel,
                    typeDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            List<INamedTypeSymbol> containingTypes = SymbolsHelper.GetContainingTypes(classSymbol);
            
            using StringWriter stringWriter = new StringWriter();
            using IndentedTextWriter textWriter = new IndentedTextWriter(stringWriter, "    ");
            
            textWriter.WriteLine("// <auto-generated/>");
            textWriter.WriteLine();
            textWriter.WriteLine("using Visitor.NET;");
            textWriter.WriteLine();
            textWriter.WriteLine($"namespace {namespaceName};");
            textWriter.WriteLine();
            
            // add containing types declarations
            foreach (INamedTypeSymbol containingType in containingTypes)
            {
                TypeKind kind = containingType.IsRecord ? TypeKind.Record : TypeKind.Class;
                textWriter.WriteLine($"public partial {kind.ToString().ToLower()} {containingType.Name}");
                textWriter.WriteLine("{");
                textWriter.Indent++;
            }

            textWriter.WriteLine($"public partial {typeKind.ToString().ToLower()} {visitableTypeName} :");
            textWriter.WriteLine($"    IVisitable<{visitableTypeName}>");
            textWriter.WriteLine("{");
            textWriter.Indent++;
            
            // add implementation
            textWriter.WriteLine("public override TReturn Accept<TReturn>(");
            textWriter.WriteLine($"    IVisitor<{baseTypeName}, TReturn> visitor) =>");
            textWriter.WriteLine("    Accept(visitor);");
            textWriter.WriteLineNoTabs(string.Empty);
            textWriter.WriteLine("public TReturn Accept<TReturn>(");
            textWriter.WriteLine($"    IVisitor<{visitableTypeName}, TReturn> visitor) =>");
            textWriter.WriteLine("    visitor.Visit(this);");

            textWriter.Indent--;
            textWriter.WriteLine("}");
            
            // add closing braces
            foreach (INamedTypeSymbol _ in containingTypes)
            {
                textWriter.Indent--;
                textWriter.WriteLine("}");
            }

            context.AddSource(
                $"{visitableTypeName}.g.cs",
                SourceText.From(stringWriter.ToString(), Encoding.UTF8));
        }
    }
}

internal record VisitableInfo(
    TypeKind Kind,
    string BaseTypeName,
    string VisitableTypeName,
    TypeDeclarationSyntax TypeDeclarationSyntax);

internal enum TypeKind
{
    Class,
    Record
}