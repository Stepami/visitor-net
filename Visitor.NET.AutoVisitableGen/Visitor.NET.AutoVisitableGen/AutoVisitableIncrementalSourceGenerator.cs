using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Visitor.NET.AutoVisitableGen;

[Generator]
public class AutoVisitableIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string AttributeSourceCode = @"// <auto-generated/>

namespace Visitor.NET;
                   
[System.AttributeUsage(System.AttributeTargets.Class)]
public class AutoVisitableAttribute<T> : System.Attribute
    where T : IVisitable<T>
{
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "AutoVisitableAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is TypeDeclarationSyntax { AttributeLists.Count: > 0 } candidate
                              and not InterfaceDeclarationSyntax &&
                          candidate.Modifiers.Any(SyntaxKind.PublicKeyword) &&
                          candidate.Modifiers.Any(SyntaxKind.PartialKeyword) &&
                          !candidate.Modifiers.Any(SyntaxKind.StaticKeyword),
                (ctx, _) => GetTypeDeclarationForSourceGen(ctx))
            .Where(t => t is not null)
            .Select((x, _) => x!);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    private static VisitableInfo? GetTypeDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var typeDeclarationSyntax = (TypeDeclarationSyntax)context.Node;

        foreach (var attributeSyntax in typeDeclarationSyntax.AttributeLists
                     .SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (ModelExtensions.GetSymbolInfo(
                    context.SemanticModel,
                    attributeSyntax).Symbol is not IMethodSymbol)
                continue;

            if (typeDeclarationSyntax is InterfaceDeclarationSyntax)
                continue;

            if (attributeSyntax.Name is not GenericNameSyntax genericAttribute)
                continue;

            var attributeName = genericAttribute.Identifier.Text;

            if (attributeName is not "AutoVisitable" and "AutoVisitableAttribute")
                continue;

            var baseType = genericAttribute.TypeArgumentList.Arguments.FirstOrDefault()?.ToString();
            if (baseType is null)
                continue;

            var visitableName = typeDeclarationSyntax.Identifier.Text;
            TypeKind? kind = typeDeclarationSyntax.Keyword.Text switch
            {
                "class" => TypeKind.Class,
                "record" => TypeKind.Record,
                _ => null
            };
            if (kind is null)
                return null;

            return new VisitableInfo(
                kind.Value,
                baseType,
                visitableName,
                typeDeclarationSyntax);
        }

        return null;
    }

    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<VisitableInfo> visitableInfos) 
    {
        foreach (var visitableInfo in visitableInfos)
        {
            var typeDeclarationSyntax = visitableInfo.TypeDeclarationSyntax;

            var semanticModel = compilation.GetSemanticModel(typeDeclarationSyntax.SyntaxTree);

            if (ModelExtensions.GetDeclaredSymbol(
                    semanticModel,
                    typeDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var code = $@"// <auto-generated/>

using Visitor.NET;

namespace {namespaceName};

public partial {visitableInfo.Kind.ToString().ToLower()} {visitableInfo.VisitableTypeName} :
    IVisitable<{visitableInfo.VisitableTypeName}>
{{
    public override TReturn Accept<TReturn>(
        IVisitor<{visitableInfo.BaseTypeName}, TReturn> visitor) =>
        Accept(visitor);

    public TReturn Accept<TReturn>(
        IVisitor<{visitableInfo.VisitableTypeName}, TReturn> visitor) =>
        visitor.Visit(this);
}}
";

            context.AddSource(
                $"{visitableInfo.VisitableTypeName}.g.cs",
                SourceText.From(code, Encoding.UTF8));
        }
    }
}

internal record VisitableInfo(
    TypeKind Kind,
    string BaseTypeName,
    string VisitableTypeName,
    TypeDeclarationSyntax TypeDeclarationSyntax);

internal enum TypeKind
{
    Class,
    Record
}