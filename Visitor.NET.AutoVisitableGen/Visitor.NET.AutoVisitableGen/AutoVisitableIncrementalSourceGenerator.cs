using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Visitor.NET.AutoVisitableGen;

[Generator]
public class AutoVisitableIncrementalSourceGenerator : IIncrementalGenerator
{
    private const string AttributeSourceCode = @"// <auto-generated/>

namespace Visitor.NET;
                   
[System.AttributeUsage(System.AttributeTargets.Class)]
public class AutoVisitableAttribute<T> : System.Attribute
    where T : IVisitable<T>
{
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "AutoVisitableAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var provider = context.SyntaxProvider
            .ForAttributeWithMetadataName("Visitor.NET.AutoVisitableAttribute`1",
                static (s, _) => IsSyntaxTargetForGeneration(s),
                static (ctx, _) => GetTypeDeclarationForSourceGen(ctx))
            .Where(static x => x is not null)
            .Select(static (x, _) => x!);

        context.RegisterImplementationSourceOutput(provider.Collect(), GenerateCode);
    }


    private static VisitableInfo? GetTypeDeclarationForSourceGen(
        GeneratorAttributeSyntaxContext context)
    {
        var visitable = (TypeDeclarationSyntax)context.TargetNode;

        var typedArgument = GetAttributeTypedArgument(context);
        if (typedArgument is null)
        {
            return null;
        }

        var visitableNamespace = GetNamespaceName(context.TargetSymbol);
        var typedArgumentNamespace = GetNamespaceName(typedArgument);
        
        var typedArgumentName = string.Equals(typedArgumentNamespace, visitableNamespace)
            ? typedArgument.Name
            : typedArgument.ToDisplayString();

        var kind = GetTypeKind(visitable);
        if (kind is null)
        {
            return null;
        }

        var visitableName = visitable.Identifier.Text;
        var accessModifier = context.TargetSymbol.DeclaredAccessibility.ToString().ToLower();
        
        List<ContainingTypeInfo> containingTypes = SyntaxHelper.GetContainingTypes(visitable, context.SemanticModel);

        var isBaseInterface = typedArgument.TypeKind is Microsoft.CodeAnalysis.TypeKind.Interface;
        var isParentInterface =
            (context.TargetSymbol as INamedTypeSymbol)?.BaseType?.ToDisplayString() is "object" ||
            (context.TargetSymbol as INamedTypeSymbol)?.BaseType?.Interfaces.Contains(typedArgument, SymbolEqualityComparer.Default) != true;

        return new VisitableInfo(
            kind.Value,
            typedArgumentName,
            isBaseInterface,
            isParentInterface,
            visitableName,
            visitableNamespace,
            accessModifier,
            containingTypes);
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node) =>
        node is TypeDeclarationSyntax candidate &&
        candidate.Modifiers.Any(SyntaxKind.PartialKeyword) &&
        !candidate.Modifiers.Any(SyntaxKind.ProtectedKeyword)&&
        !candidate.Modifiers.Any(SyntaxKind.PrivateKeyword) &&
        !candidate.Modifiers.Any(SyntaxKind.FileKeyword) &&
        !candidate.Modifiers.Any(SyntaxKind.StaticKeyword);

    private static TypeKind? GetTypeKind(TypeDeclarationSyntax typeDeclarationSyntax)
    {
        return typeDeclarationSyntax switch
        {
            ClassDeclarationSyntax => TypeKind.Class,
            RecordDeclarationSyntax => TypeKind.Record,
            _ => null
        };
    }

    private static string? GetNamespaceName(ISymbol contextTargetSymbol)
    {
        return contextTargetSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : contextTargetSymbol.ContainingNamespace.ToDisplayString();
    }

    private static ITypeSymbol? GetAttributeTypedArgument(GeneratorAttributeSyntaxContext context)
    {
        var attributeData = context.Attributes.FirstOrDefault(x =>
            x.AttributeClass?.OriginalDefinition.ToString() == "Visitor.NET.AutoVisitableAttribute<T>");
        return attributeData?.AttributeClass?.TypeArguments.FirstOrDefault();
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<VisitableInfo> visitableInfos)
    {
        foreach (var info in visitableInfos)
        {
            using StringWriter stringWriter = new StringWriter();
            using IndentedTextWriter textWriter = new IndentedTextWriter(stringWriter, "    ");
            
            textWriter.WriteLine("// <auto-generated/>");
            textWriter.WriteLine();
            textWriter.WriteLine("using System.Diagnostics.CodeAnalysis;");
            textWriter.WriteLine("using Visitor.NET;");
            textWriter.WriteLine();
            if (info.NamespaceName != null)
            {
                textWriter.Write($"namespace {info.NamespaceName};");
            }
            textWriter.WriteLine();
            textWriter.WriteLine();
            
            // add containing types declarations
            foreach (ContainingTypeInfo containingType in info.ContainingTypes)
            {
                textWriter.WriteLine($"{containingType.Accessibility} partial {containingType.Keyword} {containingType.Name}");
                textWriter.WriteLine("{");
                textWriter.Indent++;
            }
            textWriter.WriteLine($"{info.AccessModifier} partial {info.Kind.ToString().ToLower()} {info.TypeName} :");
            textWriter.WriteLine($"    IVisitable<{info.TypeName}>");
            textWriter.WriteLine("{");
            textWriter.Indent++;
            
            // add implementation
            if (info is { IsBaseInterface: true, IsParentInterface: true })
            {
                textWriter.WriteLine("[ExcludeFromCodeCoverage]");
                textWriter.WriteLine("public TReturn Accept<TReturn>(");
                textWriter.WriteLine($"    IVisitor<{info.BaseTypeName}, TReturn> visitor)");
                textWriter.WriteLine("{");
                textWriter.WriteLine($"    IVisitor<{info.TypeName}, TReturn> concreteVisitor = visitor;");
                textWriter.WriteLine("    return Accept(concreteVisitor);");
                textWriter.WriteLine("}");
                textWriter.WriteLineNoTabs(string.Empty);
                textWriter.WriteLine("[ExcludeFromCodeCoverage]");
                textWriter.WriteLine("public TReturn Accept<TReturn>(");
                textWriter.WriteLine($"    IVisitor<{info.TypeName}, TReturn> visitor) =>");
                textWriter.WriteLine("    visitor.Visit(this);");
            }
            else
            {
                textWriter.WriteLine("[ExcludeFromCodeCoverage]");
                textWriter.WriteLine("public override TReturn Accept<TReturn>(");
                textWriter.WriteLine($"    IVisitor<{info.BaseTypeName}, TReturn> visitor) =>");
                textWriter.WriteLine("    Accept(visitor);");
                textWriter.WriteLineNoTabs(string.Empty);
                textWriter.WriteLine("[ExcludeFromCodeCoverage]");
                textWriter.WriteLine("public TReturn Accept<TReturn>(");
                textWriter.WriteLine($"    IVisitor<{info.TypeName}, TReturn> visitor) =>");
                textWriter.WriteLine("    visitor.Visit(this);");
            }

            textWriter.Indent--;
            textWriter.WriteLine("}");
            
            // add closing braces
            foreach (var _ in info.ContainingTypes)
            {
                textWriter.Indent--;
                textWriter.WriteLine("}");
            }

            var code = stringWriter.ToString();

            context.AddSource($"{info.TypeName}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}